#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Atom, Bool, List, Typed

from . import byteplay as bp
from . import enaml_ast
from .compiler_base import CompilerBase


class VarPool(Atom):
    """ A class for generating private variable names.

    """
    #: The pool of currently used variable names.
    pool = Typed(set, ())

    def new(self):
        """ Get a new private variable name.

        Returns
        -------
        result : str
            An unused variable name.

        """
        var = '_[var_%d]' % len(self.pool)
        self.pool.add(var)
        return var

    def release(self, name):
        """ Return a variable name to the pool.

        Parameters
        ----------
        name : str
            The variable name which is free to be reused.

        """
        self.pool.discard(name)


class BlockCompiler(CompilerBase):
    """ A base class for creating block compilers.

    This class provides the functionality which is common between the
    'enamldef' and 'template' block compilers.

    """
    #: A pool for generating unique private variable names.
    var_pool = Typed(VarPool, ())

    #: The set of parameter and local variable names. This should be
    #: populated by a subclass with "compile-time" local variables
    #: which can be used to load declarative and template instances.
    local_vars = Typed(set, ())

    #: A bool indicating whether or not the block has variables which
    #: are visible as locals to an instantiated declarative component.
    #: This will include template parameters and const expressions, and
    #: identifiers of declarative components. This should be set to True
    #: by a block which has local variables.
    has_locals = Bool(False)

    #: The stack of variable names of the generated class objects.
    class_stack = List()

    #: The stack of variable names of the generated node objects.
    node_stack = List()

    #: The stack of attribute names for attributes being bound.
    bind_stack = List()

    #: The stack code objects generated by the Python ast vistors.
    code_stack = List()

    #--------------------------------------------------------------------------
    # Reimplementations
    #--------------------------------------------------------------------------
    def load_globals(self):
        """ Load the globals onto the TOS.

        This is reimplemented to load the globals from fast locals. The
        'fetch_globals' method must be called at the start of the block
        in order to store the globals as locals.

        """
        self.code_ops.append((bp.LOAD_FAST, '_[f_globals]'))

    def load_helper(self, name):
        """ Load a compiler helper onto the TOS.

        This is reimplemented to load the helpers from fast locals. The
        'fetch_helpers' method must be called at the start of the block
        in order to store the helpers as locals.

        """
        self.code_ops.extend([
            (bp.LOAD_FAST, '_[helpers]'),   # helpers
            (bp.LOAD_CONST, name),          # helpers -> name
            (bp.BINARY_SUBSCR, None),       # helper
        ])

    #--------------------------------------------------------------------------
    # Utilities
    #--------------------------------------------------------------------------
    def load_name(self, name):
        """ Load a name onto the TOS.

        This method is used to load the name for template inst and
        declarative components. It loads from fast locals if the name
        is in the 'local_vars' set, otherwise it loads from globals.

        """
        if name in self.local_vars:
            op = bp.LOAD_FAST
        else:
            op = bp.LOAD_GLOBAL
        self.code_ops.append((op, name))

    def fetch_globals(self):
        """ Fetch the globals and store into fast locals.

        """
        self.code_ops.extend([
            (bp.LOAD_GLOBAL, 'globals'),        # func
            (bp.CALL_FUNCTION, 0x0000),         # globals
            (bp.STORE_FAST, '_[f_globals]'),    # <empty>
        ])

    def fetch_helpers(self):
        """ Fetch the compiler helpers and store into fast locals.

        """
        self.code_ops.extend([
            (bp.LOAD_GLOBAL, '__compiler_helpers'), # helpers
            (bp.STORE_FAST, '_[helpers]'),          # <empty>
        ])

    def make_scope_key(self):
        """ Create a scope key and store into fast locals.

        """
        self.load_helper('make_object')
        self.code_ops.extend([                  # helper
            (bp.CALL_FUNCTION, 0x0000),         # key
            (bp.STORE_FAST, '_[scope_key]'),    # <empty>
        ])

    def load_scope_key(self):
        """ Load the scope key onto the TOS.

        """
        self.code_ops.append((bp.LOAD_FAST, '_[scope_key]'))

    def validate_declarative(self):
        """ Validate that the TOS is a Declarative subclass.

        """
        with self.try_squash_raise():
            self.code_ops.append(                       # class
                (bp.DUP_TOP, None)                      # class -> class
            )
            self.load_helper('validate_declarative')    # class -> class -> helper
            self.code_ops.extend([
                (bp.ROT_TWO, None),                     # class -> helper -> class
                (bp.CALL_FUNCTION, 0x0001),             # class -> retval
                (bp.POP_TOP, None),                     # class
            ])

    def has_identifiers(self, node):
        """ Get whether or not a node block has identifiers.

        Parameters
        ----------
        node : EnamlDef, ChildDef, Template, or TemplateInst
            The enaml ast node of interest.

        Returns
        -------
        result : bool
            True if the node or any of it's decendents have identifiers,
            False otherwise.

        """
        EnamlDef = enaml_ast.EnamlDef
        ChildDef = enaml_ast.ChildDef
        Template = enaml_ast.Template
        TemplateInst = enaml_ast.TemplateInst
        stack = [node]
        while stack:
            node = stack.pop()
            if isinstance(node, (ChildDef, EnamlDef)):
                if node.identifier:
                    return True
                stack.extend(node.body)
            elif isinstance(node, TemplateInst):
                if node.identifiers:
                    return True
                stack.extend(node.body)
            elif isinstance(node, Template):
                stack.extend(node.body)
        return False

    def translate_locals(self, code_list):
        """ Translate the LOAD_NAME and STORE_NAME opcodes.

        This method operates on the code list in-place and translates
        the list to operate properly from within it's own local scope.
        This is used by the StorageExpr visitors to translate the code
        for 'const' and 'static' expressions.

        Parameters
        ----------
        code_list : list
            The list of byteplay code ops. This list is modified in
            place.

        Returns
        -------
        result : list
            The list of local variables to load before invoking the
            function created for the codelist.

        """
        arg_names = []
        stored_names = set()
        local_vars = self.local_vars
        for idx, (op, op_arg) in enumerate(code_list):
            if op == bp.STORE_NAME:
                stored_names.add(op_arg)
                code_list[idx] = (bp.STORE_FAST, op_arg)
        for idx, (op, op_arg) in enumerate(code_list):
            if op == bp.LOAD_NAME:
                if op_arg in local_vars:
                    op = bp.LOAD_FAST
                    arg_names.append(op_arg)
                elif op_arg in stored_names:
                    op = bp.LOAD_FAST
                else:
                    op = bp.LOAD_GLOBAL
                code_list[idx] = (op, op_arg)
            elif op == bp.DELETE_NAME and op_arg in stored_names:
                code_list[idx] = (bp.DELETE_FAST, op_arg)  # py2.6 list comps
        return arg_names

    def needs_subclass(cls, node):
        """ Get whether or not a ChildDef node needs subclassing.

        A child def class must be subclassed if it uses storage or
        has attribute bindings.

        Parameters
        ----------
        node : ChildDef
            The child def node of interest.

        Returns
        -------
        result : bool
            True if the class must be subclassed, False otherwise.

        """
        types = (enaml_ast.StorageExpr, enaml_ast.Binding)
        return any(isinstance(item, types) for item in node.body)

    def needs_engine(cls, node):
        """ Get whether or not a node needs an expression engine.

        A node requires an engine if it has attribute bindings.

        Parameters
        ----------
        node : EnamlDef or ChildDef
            The enaml ast node of interest.

        Returns
        -------
        result : bool
            True if the node class requires an engine, False otherwise.

        """
        for item in node.body:
            if isinstance(item, enaml_ast.Binding):
                return True
            if isinstance(item, enaml_ast.StorageExpr):
                if item.expr is not None:
                    return True
        return False

    #--------------------------------------------------------------------------
    # Visitors
    #--------------------------------------------------------------------------
    def visit_ChildDef(self, node):
        """ The compiler visitor for a ChildDef node.

        """
        # Claim the variables needed for the class and construct node
        class_var = self.var_pool.new()
        node_var = self.var_pool.new()

        self.set_lineno(node.lineno)

        # Load and validate the child class
        self.load_name(node.typename)
        self.validate_declarative()

        # Subclass the child class if needed
        if self.needs_subclass(node):
            self.code_ops.extend([              # class
                (bp.LOAD_CONST, node.typename), # class -> name
                (bp.ROT_TWO, None),             # name -> class
                (bp.BUILD_TUPLE, 1),            # name -> bases
                (bp.BUILD_MAP, 0),              # name -> bases -> dict
                (bp.LOAD_GLOBAL, '__name__'),   # name -> bases -> dict -> __name__
                (bp.LOAD_CONST, '__module__'),  # name -> bases -> dict -> __name__ -> '__module__'
                (bp.STORE_MAP, None),           # name -> bases -> dict
                (bp.BUILD_CLASS, None),         # class
            ])

        # Store the class as a local
        self.code_ops.extend([                  # class
            (bp.DUP_TOP, None),                 # class -> class
            (bp.STORE_FAST, class_var),         # class
        ])

        # Build and store the construct node
        self.load_helper('construct_node')
        self.code_ops.extend([                      # class -> helper
            (bp.ROT_TWO, None),                     # helper -> class
            (bp.LOAD_CONST, node.identifier),       # helper -> class -> identifier
        ])
        self.load_scope_key()
        self.code_ops.extend([                      # helper -> class -> identifier -> key
            (bp.LOAD_CONST, self.has_locals),       # helper -> class -> identifier -> key -> bool
            (bp.CALL_FUNCTION, 0x0004),             # node
            (bp.STORE_FAST, node_var),              # <empty>
        ])

        # Build an engine for the new class if needed.
        if self.needs_engine(node):
            self.load_helper('make_engine')
            self.code_ops.extend([                  # helper
                (bp.LOAD_FAST, class_var),          # helper -> class
                (bp.CALL_FUNCTION, 0x0001),         # engine
                (bp.LOAD_FAST, class_var),          # engine -> class
                (bp.STORE_ATTR, '__engine__'),      # <empty>
            ])

        # Populate the body of the node
        self.class_stack.append(class_var)
        self.node_stack.append(node_var)
        for item in node.body:
            self.visit(item)
        self.class_stack.pop()
        self.node_stack.pop()

        # Add this node to the parent node
        self.code_ops.extend([                      # <empty>
            (bp.LOAD_FAST, self.node_stack[-1]),    # parent
            (bp.LOAD_ATTR, 'children'),             # children
            (bp.LOAD_ATTR, 'append'),               # append
            (bp.LOAD_FAST, node_var),               # append -> node
            (bp.CALL_FUNCTION, 0x0001),             # retval
            (bp.POP_TOP, None),                     # <empty>
        ])

        # Release the held variables
        self.var_pool.release(class_var)
        self.var_pool.release(node_var)

    def visit_StorageExpr(self, node):
        """ The compiler visitor for a StorageExpr node.

        """
        self.set_lineno(node.lineno)
        with self.try_squash_raise():
            self.load_helper('add_storage')
            self.code_ops.extend([                      # helper
                (bp.LOAD_FAST, self.class_stack[-1]),   # helper -> class
                (bp.LOAD_CONST, node.name),             # helper -> class -> name
            ])
            if node.typename:
                self.load_name(node.typename)           # helper -> class -> name -> type
            else:
                self.code_ops.append(
                    (bp.LOAD_CONST, None)               # helper -> class -> name -> None
                )
            self.code_ops.extend([
                (bp.LOAD_CONST, node.kind),             # helper -> class -> name -> type -> kind
                (bp.CALL_FUNCTION, 0x0004),             # retval
                (bp.POP_TOP, None),                     # <empty>
            ])
        if node.expr is not None:
            self.bind_stack.append(node.name)
            self.visit(node.expr)
            self.bind_stack.pop()

    def visit_Binding(self, node):
        """ The compiler visitor for a Binding node.

        """
        self.bind_stack.append(node.name)
        self.visit(node.expr)
        self.bind_stack.pop()

    def visit_OperatorExpr(self, node):
        """ The compiler visitor for an OperatorExpr node.

        """
        self.visit(node.value)
        code = self.code_stack.pop()
        self.set_lineno(node.lineno)
        with self.try_squash_raise():
            self.load_helper('run_operator')
            self.code_ops.extend([                      # helper
                (bp.LOAD_FAST, self.node_stack[-1]),    # helper -> node
                (bp.LOAD_CONST, self.bind_stack[-1]),   # helper -> node -> name
                (bp.LOAD_CONST, node.operator),         # helper -> node -> name -> op
                (bp.LOAD_CONST, code),                  # helper -> node -> name -> op -> code
            ])
            self.load_globals()
            self.code_ops.extend([                      # helper -> node -> name -> op -> code -> globals
                (bp.CALL_FUNCTION, 0x0005),             # retval
                (bp.POP_TOP, None),                     # <empty>
            ])

    def visit_PythonExpression(self, node):
        """ The compiler visitor for a PythonExpression node.

        """
        code = compile(node.ast, self.filename, mode='eval')
        self.code_stack.append(code)

    def visit_PythonModule(self, node):
        """ The compiler visitor for a PythonModule node.

        """
        code = compile(node.ast, self.filename, mode='exec')
        self.code_stack.append(code)
