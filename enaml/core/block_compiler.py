#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from itertools import count

from atom.api import Int, IntEnum, List, Typed

from .compiler_base import CompilerBase
from .enaml_ast import Binding, StorageExpr, AliasExpr


class CompilerPass(IntEnum):
    """ An enum defining the various passes of the compiler.

    """
    #: The first pass of compilation where the nodes are counted.
    CountNodes = 1

    #: The second pass of compilation where the compiler nodes are
    #: generated and assembled into the type hierarchy.
    BuildNodes = 2

    #: The third pass of compilation where data is bound to the nodes.
    BindData = 3


class BlockCompiler(CompilerBase):
    """ A base class for creating block compilers.

    This class implements common logic for the enamldef and template
    compilers.

    """
    #: A stack of node indices used for tagging the ast nodes.
    index_stack = List()

    #: A counter for generating compiler indices.
    index_counter = Typed(count)

    #: The number of nodes which will be generated by the block.
    node_count = Int()

    #: The current pass of the compiler.
    comp_pass = Typed(CompilerPass)

    #--------------------------------------------------------------------------
    # Utilities
    #--------------------------------------------------------------------------
    def should_store_locals(self, node):
        """ Get whether or not a node should store its locals.

        A node must store its local scope if it has alias exprs,
        attribute bindings, or storage exprs with default bindings.

        Parameters
        ----------
        node : EnamlDef or ChildDef
            The ast node of interest.

        Returns
        -------
        result : bool
            True if instances of the enamldef should store their local
            scopes, False otherwise.

        """
        types = (AliasExpr, Binding)
        for item in node.body:
            if isinstance(item, types):
                return True
            if isinstance(item, StorageExpr) and item.expr is not None:
                return True
        return False

    def prepare_block(self):
        """ Prepare the code block for code generation.

        This method will setup the state variables needed by the
        rest of the code generators for the block.

        """
        cg = self.code_generator

        # Store the globals and the compiler helpers as fast locals.
        cg.store_globals_to_fast()
        cg.store_helpers_to_fast()

        # Create a local scope key for the block.
        cg.load_helper_from_fast('make_object')
        cg.call_function()
        cg.store_scope_key()

        # Create node id map for the block.
        cg.build_map()
        cg.store_node_map()

        # Create the node list for the block.
        cg.load_const(None)
        cg.build_list(1)
        cg.load_const(self.node_count)
        cg.binary_multiply()
        cg.store_node_list()

    def call_from(self, pg):
        """ Invoke the current code generator as a function.

        Parameters
        ----------
        pg : CodeGenerator
            The outer parent code generator from which to invoke
            the function.

        """
        cg = self.code_generator

        # Add in the return value ops and generate the code.
        cg.load_const(None)
        cg.return_value()
        cg.args = [
            cg.scope_key, cg.node_map, cg.node_list, cg.f_globals, cg.c_helpers
        ]
        code = cg.to_code()

        # Invoke the code object as a function.
        pg.load_const(code)
        pg.make_function()
        pg.load_fast(pg.scope_key)
        pg.load_fast(pg.node_map)
        pg.load_fast(pg.node_list)
        pg.load_fast(pg.f_globals)
        pg.load_fast(pg.c_helpers)
        pg.call_function(5)
        pg.pop_top()

    def handle_child_def(self, node, parent, index):
        """ The handler for a childdef node.

        """
        cg = self.code_generator

        # Set the line number and load the child class
        cg.set_lineno(node.lineno)
        cg.load_name(node.typename)

        # Validate the type of the child
        with cg.try_squash_raise():
            cg.dup_top()
            cg.load_helper_from_fast('validate_declarative')
            cg.rot_two()                            # base -> helper -> base
            cg.call_function(1)                     # base -> retval
            cg.pop_top()                            # base

        # Subclass the child class if needed
        store_types = (StorageExpr, AliasExpr)
        if any(isinstance(item, store_types) for item in node.body):
            cg.load_const(node.typename)
            cg.rot_two()
            cg.build_tuple(1)
            cg.build_map()
            cg.load_global('__name__')
            cg.load_const('__module__')
            cg.store_map()                          # name -> bases -> dict
            cg.build_class()                        # class

        # Build the declarative compiler node
        store_locals = self.should_store_locals(node)
        cg.load_helper_from_fast('declarative_node')
        cg.rot_two()
        cg.load_const(node.identifier)
        cg.load_scope_key()
        cg.load_const(store_locals)                 # helper -> class -> identifier -> key -> bool
        cg.call_function(4)                         # node

        # Store this node to the node list.
        cg.store_node(index)

        #: Store the node in the node map if needed.
        if node.identifier:
            cg.load_node_map()
            cg.load_node(index)
            cg.load_const(node.identifier)
            cg.store_map()
            cg.pop_top()

        # Append this node to the parent node
        cg.append_node(parent, index)

    def handle_storage_expr(self, node, index):
        """ The handler for a storage expresssion node.

        """
        cg = self.code_generator
        with cg.try_squash_raise():
            cg.set_lineno(node.lineno)
            cg.load_helper_from_fast('add_storage')
            cg.load_node(index)
            cg.load_const(node.name)
            if node.typename:
                cg.load_name(node.typename)
            else:
                cg.load_const(None)
            cg.load_const(node.kind)                # helper -> class -> name -> type -> kind
            cg.call_function(4)                     # retval
            cg.pop_top()

    def handle_alias_expr(self, node, index):
        """ The handler for an alias expression node.

        """
        cg = self.code_generator
        with cg.try_squash_raise():
            cg.set_lineno(node.lineno)
            cg.load_helper_from_fast('add_alias')
            cg.load_node_map()
            cg.load_node(index)
            cg.load_const(node.name)
            cg.load_const(node.target)
            cg.load_const(node.attr)
            cg.call_function(5)
            cg.pop_top()

    def handle_operator_expr(self, node, name, index):
        """ The handler for an operator expression node.

        """
        cg = self.code_generator
        code = self.visit(node.value)
        with cg.try_squash_raise():
            cg.set_lineno(node.lineno)
            cg.load_helper_from_fast('run_operator')
            cg.load_node(index)
            cg.load_const(name)
            cg.load_const(node.operator)
            cg.load_const(code)
            cg.load_globals_from_fast()             # helper -> node -> name -> op -> code -> globals
            cg.call_function(5)
            cg.pop_top()

    #--------------------------------------------------------------------------
    # Visitors
    #--------------------------------------------------------------------------
    def visit_ChildDef(self, node):
        """ The compiler visitor for a ChildDef node.

        """
        comp_pass = self.comp_pass
        parent = self.index_stack[-1]
        index = self.index_counter.next()
        self.index_stack.append(index)

        if comp_pass == CompilerPass.CountNodes:
            self.node_count += 1
        elif comp_pass == CompilerPass.BuildNodes:
            self.handle_child_def(node, parent, index)

        for item in node.body:
            self.visit(item)

        self.index_stack.pop()

    def visit_TemplateInst(self, node):
        """ The compiler visitor for a TemplateInst node.

        """
        cg = self.code_generator
        cg.set_lineno(node.lineno)

        # Load and validate the template
        self.load_name(node.name)
        cg.load_helper_from_fast('validate_template')
        cg.rot_two()
        cg.call_function(1)

        # Load the arguments for the instantiation call
        arguments = node.arguments
        for arg in arguments.args:
            self.safe_eval_ast(arg.ast, node.name, arg.lineno)
        if arguments.stararg:
            arg = arguments.stararg
            self.safe_eval_ast(arg.ast, node.name, arg.lineno)

        # Instantiate the template
        argcount = len(arguments.args)
        varargs = bool(arguments.stararg)
        if varargs:
            cg.call_function_var(argcount)
        else:
            cg.call_function(argcount)

        # Validate the instantiation size, if needed.
        names = ()
        starname = ''
        identifiers = node.identifiers
        if identifiers is not None:
            names = tuple(identifiers.names)
            starname = identifiers.starname
            cg.load_helper_from_fast('validate_unpack_size')
            cg.rot_two()
            cg.load_const(len(names))
            cg.load_const(bool(starname))
            cg.call_function(3)

        # Load and call the helper to create the compiler node
        cg.load_helper_from_fast('template_inst_node')
        cg.rot_two()
        cg.load_const(names)
        cg.load_const(starname)
        cg.load_fast(self.scope_key)
        cg.call_function(4)

        # Append the node to the parent node
        cg.load_fast(self.node_stack[-1])
        cg.load_attr('children')
        cg.load_attr('append')
        cg.rot_two()
        cg.call_function(1)
        cg.pop_top()

    def visit_StorageExpr(self, node):
        """ The compiler visitor for a StorageExpr node.

        """
        if self.comp_pass == CompilerPass.BindData:
            self.handle_storage_expr(node, self.index_stack[-1])

        if node.expr is not None:
            self.visit(node.expr, node.name)

    def visit_AliasExpr(self, node):
        """ The compiler visitor for an AliasExpr node.

        """
        if self.comp_pass == CompilerPass.BindData:
            self.handle_alias_expr(node, self.index_stack[-1])

    def visit_Binding(self, node):
        """ The compiler visitor for a Binding node.

        """
        self.visit(node.expr, node.name)

    def visit_ExBinding(self, node):
        """ The compiler visitor for an ExBinding node.

        """
        parts = (node.name, node.binding.name)
        self.visit(node.binding.expr, parts)

    def visit_OperatorExpr(self, node, name):
        """ The compiler visitor for an OperatorExpr node.

        """
        if self.comp_pass == CompilerPass.BindData:
            self.handle_operator_expr(node, name, self.index_stack[-1])

    def visit_PythonExpression(self, node):
        """ The compiler visitor for a PythonExpression node.

        """
        cg = self.code_generator
        return compile(node.ast, cg.filename, mode='eval')

    def visit_PythonModule(self, node):
        """ The compiler visitor for a PythonModule node.

        """
        cg = self.code_generator
        return compile(node.ast, cg.filename, mode='exec')
