#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Atom, Bool, List, Typed

from . import byteplay as bp
from . import enaml_ast
from .compiler_base import CompilerBase


class VarPool(Atom):
    """ A class for generating private variable names.

    """
    #: The pool of currently used variable names.
    pool = Typed(set, ())

    def new(self):
        """ Get a new private variable name.

        Returns
        -------
        result : str
            An unused variable name.

        """
        var = '_[var_%d]' % len(self.pool)
        self.pool.add(var)
        return var

    def release(self, name):
        """ Return a variable name to the pool.

        Parameters
        ----------
        name : str
            The variable name which is free to be reused.

        """
        self.pool.discard(name)


class BlockCompiler(CompilerBase):
    """ A base class for creating block compilers.

    This class provides the functionality which is common between the
    'enamldef' and 'template' block compilers.

    """
    #: A pool for generating unique private variable names.
    var_pool = Typed(VarPool, ())

    #: A bool indicating whether or not the block has variables which
    #: are visible as locals to an instantiated declarative component.
    #: This should be set to True by a block which has local variables.
    has_locals = Bool(False)

    #: The stack of variable names of the generated class objects.
    class_stack = List()

    #: The stack of variable names of the generated node objects.
    node_stack = List()

    #: The stack of attribute names for attributes being bound.
    bind_stack = List()

    #: The stack code objects generated by the Python ast vistors.
    code_stack = List()

    #--------------------------------------------------------------------------
    # Reimplementations
    #--------------------------------------------------------------------------
    def load_globals(self):
        """ Load the globals onto the TOS.

        This is reimplemented to load the globals from fast locals. The
        'fetch_globals' method must be called at the start of the block
        in order to store the globals as locals.

        """
        self.code_ops.append((bp.LOAD_FAST, '_[f_globals]'))

    def load_helper(self, name):
        """ Load a compiler helper onto the TOS.

        This is reimplemented to load the helpers from fast locals. The
        'fetch_helpers' method must be called at the start of the block
        in order to store the helpers as locals.

        """
        self.code_ops.extend([
            (bp.LOAD_FAST, '_[helpers]'),   # helpers
            (bp.LOAD_CONST, name),          # helpers -> name
            (bp.BINARY_SUBSCR, None),       # helper
        ])

    #--------------------------------------------------------------------------
    # Utilities
    #--------------------------------------------------------------------------
    def fetch_globals(self):
        """ Fetch the globals and store into fast locals.

        """
        self.code_ops.extend([
            (bp.LOAD_GLOBAL, 'globals'),        # func
            (bp.CALL_FUNCTION, 0x0000),         # globals
            (bp.STORE_FAST, '_[f_globals]'),    # <empty>
        ])

    def fetch_helpers(self):
        """ Fetch the compiler helpers and store into fast locals.

        """
        self.code_ops.extend([
            (bp.LOAD_GLOBAL, '__compiler_helpers'), # helpers
            (bp.STORE_FAST, '_[helpers]'),          # <empty>
        ])

    def make_scope_key(self):
        """ Create a scope key and store into fast locals.

        """
        self.load_helper('make_scope_key')
        self.code_ops.extend([                  # helper
            (bp.CALL_FUNCTION, 0x0000),         # key
            (bp.STORE_FAST, '_[scope_key]'),    # <empty>
        ])

    def load_scope_key(self):
        """ Load the scope key onto the TOS.

        """
        self.code_ops.append((bp.LOAD_FAST, '_[scope_key]'))

    def needs_subclass(cls, node):
        """ Get whether or not a ChildDef node needs subclassing.

        A child def class must be subclassed if it uses storage or
        has attribute bindings.

        Parameters
        ----------
        node : ChildDef
            The child def node of interest.

        Returns
        -------
        result : bool
            True if the class must be subclassed, False otherwise.

        """
        types = (enaml_ast.StorageExpr, enaml_ast.Binding)
        return any(isinstance(item, types) for item in node.body)

    def needs_engine(cls, node):
        """ Get whether or not a node needs an expression engine.

        A node requires an engine if it has attribute bindings.

        Parameters
        ----------
        node : EnamlDef or ChildDef
            The enaml ast node of interest.

        Returns
        -------
        result : bool
            True if the node class requires an engine, False otherwise.

        """
        for item in node.body:
            if isinstance(item, enaml_ast.Binding):
                return True
            if isinstance(item, enaml_ast.StorageExpr):
                if item.expr is not None:
                    return True
        return False

    #--------------------------------------------------------------------------
    # Visitors
    #--------------------------------------------------------------------------
    def visit_ChildDef(self, node):
        """ The compiler visitor for a ChildDef node.

        """
        # Claim the variables needed for the class and construct node
        class_var = self.var_pool.new()
        node_var = self.var_pool.new()

        self.set_lineno(node.lineno)

        # Load and validate the child class
        self.load_name(node.typename)
        self.validate_declarative()

        # Subclass the child class if needed
        if self.needs_subclass(node):
            self.code_ops.extend([              # class
                (bp.LOAD_CONST, node.typename), # class -> name
                (bp.ROT_TWO, None),             # name -> class
                (bp.BUILD_TUPLE, 1),            # name -> bases
                (bp.BUILD_MAP, 0),              # name -> bases -> dict
                (bp.LOAD_GLOBAL, '__name__'),   # name -> bases -> dict -> __name__
                (bp.LOAD_CONST, '__module__'),  # name -> bases -> dict -> __name__ -> '__module__'
                (bp.STORE_MAP, None),           # name -> bases -> dict
                (bp.BUILD_CLASS, None),         # class
            ])

        # Store the class as a local
        self.code_ops.extend([                  # class
            (bp.DUP_TOP, None),                 # class -> class
            (bp.STORE_FAST, class_var),         # class
        ])

        # Build and store the construct node
        self.load_helper('construct_node')
        self.code_ops.extend([                      # class -> helper
            (bp.ROT_TWO, None),                     # helper -> class
            (bp.LOAD_CONST, node.identifier),       # helper -> class -> identifier
        ])
        self.load_scope_key()
        self.code_ops.extend([                      # helper -> class -> identifier -> key
            (bp.LOAD_CONST, self.has_locals),       # helper -> class -> identifier -> key -> bool
            (bp.CALL_FUNCTION, 0x0004),             # node
            (bp.STORE_FAST, node_var),              # <empty>
        ])

        # Build an engine for the new class if needed.
        if self.needs_engine(node):
            self.load_helper('make_engine')
            self.code_ops.extend([                  # helper
                (bp.LOAD_FAST, class_var),          # helper -> class
                (bp.CALL_FUNCTION, 0x0001),         # engine
                (bp.LOAD_FAST, class_var),          # engine -> class
                (bp.STORE_ATTR, '__engine__'),      # <empty>
            ])

        # Populate the body of the node
        self.class_stack.append(class_var)
        self.node_stack.append(node_var)
        for item in node.body:
            self.visit(item)
        self.class_stack.pop()
        self.node_stack.pop()

        # Add this node to the parent node
        self.code_ops.extend([                      # <empty>
            (bp.LOAD_FAST, self.node_stack[-1]),    # parent
            (bp.LOAD_ATTR, 'children'),             # children
            (bp.LOAD_ATTR, 'append'),               # append
            (bp.LOAD_FAST, node_var),               # append -> node
            (bp.CALL_FUNCTION, 0x0001),             # retval
            (bp.POP_TOP, None),                     # <empty>
        ])

        # Release the held variables
        self.var_pool.release(class_var)
        self.var_pool.release(node_var)

    def visit_StorageExpr(self, node):
        """ The compiler visitor for a StorageExpr node.

        """
        self.set_lineno(node.lineno)
        with self.try_squash_raise():
            self.load_helper('add_storage')
            self.code_ops.extend([                      # helper
                (bp.LOAD_FAST, self.class_stack[-1]),   # helper -> class
                (bp.LOAD_CONST, node.name),             # helper -> class -> name
            ])
            if node.typename:
                self.load_name(node.typename)           # helper -> class -> name -> type
            else:
                self.code_ops.append(
                    (bp.LOAD_CONST, None)               # helper -> class -> name -> None
                )
            self.code_ops.extend([
                (bp.LOAD_CONST, node.kind),             # helper -> class -> name -> type -> kind
                (bp.CALL_FUNCTION, 0x0004),             # retval
                (bp.POP_TOP, None),                     # <empty>
            ])
        if node.expr is not None:
            self.bind_stack.append(node.name)
            self.visit(node.expr)
            self.bind_stack.pop()

    def visit_Binding(self, node):
        """ The compiler visitor for a Binding node.

        """
        self.bind_stack.append(node.name)
        self.visit(node.expr)
        self.bind_stack.pop()

    def visit_OperatorExpr(self, node):
        """ The compiler visitor for an OperatorExpr node.

        """
        self.visit(node.value)
        code = self.code_stack.pop()
        self.set_lineno(node.lineno)
        with self.try_squash_raise():
            self.load_helper('run_operator')
            self.code_ops.extend([                      # helper
                (bp.LOAD_FAST, self.node_stack[-1]),    # helper -> node
                (bp.LOAD_CONST, self.bind_stack[-1]),   # helper -> node -> name
                (bp.LOAD_CONST, node.operator),         # helper -> node -> name -> op
                (bp.LOAD_CONST, code),                  # helper -> node -> name -> op -> code
            ])
            self.load_globals()
            self.code_ops.extend([                      # helper -> node -> name -> op -> code -> globals
                (bp.CALL_FUNCTION, 0x0005),             # retval
                (bp.POP_TOP, None),                     # <empty>
            ])

    def visit_PythonExpression(self, node):
        """ The compiler visitor for a PythonExpression node.

        """
        code = compile(node.ast, self.filename, mode='eval')
        self.code_stack.append(code)

    def visit_PythonModule(self, node):
        """ The compiler visitor for a PythonModule node.

        """
        code = compile(node.ast, self.filename, mode='exec')
        self.code_stack.append(code)
