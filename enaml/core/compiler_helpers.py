#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Event, Instance

from .construct_nodes import EnamlDefConstruct
from .declarative import Declarative, d_
from .exceptions import DeclarativeException
from .resolver import Resolver


def __make_enamldef_helper(dct, f_globals):
    """ A compiler helper function for creating a new EnamlDef type.

    This function is called by the bytecode generated by the Enaml
    compiler when an enaml module is imported. It is used to make new
    types from the 'enamldef' keyword.

    Parameters
    ----------
    dct : dict
        The description dictionay by the Enaml compiler.

    f_globals : dict
        The dictionary of globals for the enamldef's module.

    Returns
    -------
    result : EnamlDef
        A new enamldef subclass of the given base class.

    """
    node = EnamlDefConstruct.from_dict(dct)
    try:
        Resolver.resolve(node, f_globals)
    except DeclarativeException as e:
        # this squashes most of the traceback which is not relevant
        # for the user. This handler should be moved into the compiled
        # bytecode so that no internal code shows up in the traceback.
        raise e
    cls = node.typeclass
    cls.__constructs__ += (node,)
    return cls


def __add_storage(klass, name, storage_type, kind):
    if storage_type is None:
        storage_type = object
    elif not isinstance(storage_type, type):
        msg = "'%s' is not a type"
        raise DeclarativeException(msg % type(storage_type).__name__)
    members = klass.members()
    m = members.get(name)
    if m is not None:
        if m.metadata is None or not m.metadata.get('d_member'):
            msg = "cannot override non-declarative member '%s'"
            raise DeclarativeException(msg % name)
        if m.metadata.get('d_final'):
            msg = "cannot override the final member '%s'"
            raise DeclarativeException(msg % name)
    if kind == 'event':
        new = d_(Event(storage_type), writable=False, final=False)
    else:
        new = d_(Instance(storage_type), final=False)
    if m is not None:
        new.set_index(m.index)
        new.copy_static_observers(m)
    else:
        new.set_index(len(members))
    new.set_name(name)
    members[name] = new
    setattr(klass, name, new)
    return klass
