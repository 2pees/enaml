#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Bool, List, Typed, Constant

from .code_generator import CodeGenerator
from .compiler_base import CompilerBase
from .compiler_util import (
    VarPool, has_identifiers, needs_engine, needs_subclass
)


class EnamlDefCompiler(CompilerBase):
    """ A compiler class for compiling 'enamldef' blocks.

    This compiler is invoked by the main EnamlCompiler class when it
    reaches an EnamlDef ast node. The main entry point is the 'compile'
    classmethod.

    """
    #: Whether instances of the block need local storage.
    has_locals = Bool(False)

    #: A variable name generator.
    var_pool = Typed(VarPool, ())

    #: The name of scope key in local storage.
    scope_key = Constant('_[scope_key]')

    #: A stack of var names for parent classes.
    class_stack = List()

    #: A stack of var names for parent nodes.
    node_stack = List()

    #: A stack of attr bind names for parent nodes.
    bind_stack = List()

    #: A stack of compiled code objects generated by visitors.
    code_stack = List()

    @classmethod
    def compile(cls, node, filename):
        """ Compile an EnamlDef node into a code object.

        Parameters
        ----------
        node : EnamlDef
            The enaml ast node representing the enamldef block.

        filename : str
            The full name of the file which contains the node.

        Returns
        -------
        result : CodeType
            A Python code object which implements the enamldef block.

        """
        compiler = cls()
        cg = compiler.code_generator
        cg.filename = filename
        compiler.visit(node)
        code = cg.to_code(
            newlocals=True, name=node.typename, firstlineno=node.lineno,
            docstring=node.docstring or None
        )
        return code

    def visit_EnamlDef(self, node):
        """ The compiler visitor for an EnamlDef node.

        """
        cg = self.code_generator

        # Determine whether declaration instances need local storage.
        self.has_locals = has_identifiers(node)

        # Claim the variables needed for the class and construct node
        class_var = self.var_pool.new()
        node_var = self.var_pool.new()

        # Prepare the block for execution
        cg.set_lineno(node.lineno)
        cg.store_globals_to_fast()
        cg.store_helpers_to_fast()
        cg.load_helper_from_fast('make_object')
        cg.call_function()
        cg.store_fast(self.scope_key)

        # Load the type name and the base class
        cg.load_helper_from_fast('make_enamldef')
        cg.load_const(node.typename)
        cg.load_global(node.base)                   # helper -> name -> base

        # Validate the type of the base class
        with cg.try_squash_raise():
            cg.dup_top()
            cg.load_helper_from_fast('validate_declarative')
            cg.rot_two()                            # helper -> name -> base -> helper -> base
            cg.call_function(1)                     # helper -> name -> base -> retval
            cg.pop_top()                            # helper -> name -> base

        # Build the enamldef class
        cg.build_tuple(1)
        cg.build_map()
        cg.load_global('__name__')
        cg.load_const('__module__')
        cg.store_map()                              # helper -> name -> bases -> dict
        if node.docstring:
            cg.load_const(node.docstring)
            cg.load_const('__doc__')
            cg.store_map()
        cg.call_function(3)                         # class

        # Store the class as a local
        cg.dup_top()
        cg.store_fast(class_var)

        # Build the construct node
        cg.load_helper_from_fast('construct_node')
        cg.rot_two()
        cg.load_const(node.identifier)
        cg.load_fast(self.scope_key)
        cg.load_const(self.has_locals)              # helper -> class -> identifier -> key -> bool
        cg.call_function(4)                         # node
        cg.store_fast(node_var)

        # Build an engine for the new class if needed.
        if needs_engine(node):
            cg.load_helper_from_fast('make_engine')
            cg.load_fast(class_var)                 # helper -> class
            cg.call_function(1)                     # engine
            cg.load_fast(class_var)                 # engine -> class
            cg.store_attr('__engine__')

        # Popuplate the body of the class
        self.class_stack.append(class_var)
        self.node_stack.append(node_var)
        for item in node.body:
            self.visit(item)
        self.class_stack.pop()
        self.node_stack.pop()

        # Store the node on the enamldef and return the class
        cg.load_fast(class_var)
        cg.dup_top()
        cg.load_fast(node_var)
        cg.rot_two()
        cg.store_attr('__node__')
        cg.return_value()

        # Release the held variables
        self.var_pool.release(class_var)
        self.var_pool.release(node_var)

    def visit_ChildDef(self, node):
        """ The compiler visitor for a ChildDef node.

        """
        cg = self.code_generator

        # Claim the variables needed for the class and construct node
        class_var = self.var_pool.new()
        node_var = self.var_pool.new()

        # Set the line number and load the child class
        cg.set_lineno(node.lineno)
        cg.load_global(node.typename)

        # Validate the type of the child
        with cg.try_squash_raise():
            cg.dup_top()
            cg.load_helper_from_fast('validate_declarative')
            cg.rot_two()                            # base -> helper -> base
            cg.call_function(1)                     # base -> retval
            cg.pop_top()                            # base

        # Subclass the child class if needed
        if needs_subclass(node):
            cg.load_const(node.typename)
            cg.rot_two()
            cg.build_tuple(1)
            cg.build_map()
            cg.load_global('__name__')
            cg.load_const('__module__')
            cg.store_map()                          # name -> bases -> dict
            cg.build_class()                        # class

        # Store the class as a local
        cg.dup_top()
        cg.store_fast(class_var)

        # Build the construct node
        cg.load_helper_from_fast('construct_node')
        cg.rot_two()
        cg.load_const(node.identifier)
        cg.load_fast(self.scope_key)
        cg.load_const(self.has_locals)              # helper -> class -> identifier -> key -> bool
        cg.call_function(4)                         # node
        cg.store_fast(node_var)

        # Build an engine for the new class if needed.
        if needs_engine(node):
            cg.load_helper_from_fast('make_engine')
            cg.load_fast(class_var)                 # helper -> class
            cg.call_function(1)                     # engine
            cg.load_fast(class_var)                 # engine -> class
            cg.store_attr('__engine__')

        # Populate the body of the node
        self.class_stack.append(class_var)
        self.node_stack.append(node_var)
        for item in node.body:
            self.visit(item)
        self.class_stack.pop()
        self.node_stack.pop()

        # Add this node to the parent node
        cg.load_fast(self.node_stack[-1])
        cg.load_attr('children')
        cg.load_attr('append')
        cg.load_fast(node_var)
        cg.call_function(1)
        cg.pop_top()

        # Release the held variables
        self.var_pool.release(class_var)
        self.var_pool.release(node_var)

    def visit_StorageExpr(self, node):
        """ The compiler visitor for a StorageExpr node.

        """
        if node.kind == 'static':
            self.visit_StorageExpr_static(node)
            return

        cg = self.code_generator
        cg.set_lineno(node.lineno)
        with self.try_squash_raise():
            cg.load_helper_from_fast('add_storage')
            cg.load_fast(self.class_stack[-1])
            cg.load_const(node.name)
            if node.typename:
                cg.load_global(node.typename)
            else:
                cg.load_const(None)
            cg.load_const(node.kind)                # helper -> class -> name -> type -> kind
            cg.call_function(4)                     # retval
            cg.pop_top()

        # Handle the expression binding, if present
        if node.expr is not None:
            self.bind_stack.append(node.name)
            self.visit(node.expr)
            self.bind_stack.pop()

    def visit_StorageExpr_static(self, node):
        """ The compiler visitor for a 'static' StorageExpr node.

        """
        cg = self.code_generator
        cg.set_lineno(node.lineno)

        # Generate the code object for the expression
        expr_cg = CodeGenerator(filename=cg.filename)
        py_node = node.expr.value
        expr_cg.set_lineno(py_node.lineno)
        expr_cg.insert_python_expr(py_node.ast, trim=False)
        expr_cg.rewrite_to_fast_locals(set())
        expr_code = expr_cg.to_code(
            newlocals=True, name=node.name, firstlineno=py_node.lineno
        )

        with cg.try_squash_raise():

            # Preload the helper and context
            cg.load_helper_from_fast('add_static_attr')
            cg.load_fast(self.class_stack[-1])
            cg.load_const(node.name)                # helper -> class -> name

            # Create and invoke the expression function
            cg.load_const(expr_code)
            cg.make_function()                      # TOS -> func
            cg.call_function()                      # TOS -> value

            # Validate the type of the value if necessary
            if node.typename:
                cg.load_helper_from_fast('type_check_expr')
                cg.rot_two()
                cg.load_global(node.typename)       # TOS -> helper -> value -> type
                cg.call_function(2)                 # TOS -> value

            # Invoke the helper to add the static attribute
            cg.call_function(3)
            cg.pop_top()

    def visit_Binding(self, node):
        """ The compiler visitor for a Binding node.

        """
        self.bind_stack.append(node.name)
        self.visit(node.expr)
        self.bind_stack.pop()

    def visit_OperatorExpr(self, node):
        """ The compiler visitor for an OperatorExpr node.

        """
        cg = self.code_generator
        self.visit(node.value)
        code = self.code_stack.pop()
        cg.set_lineno(node.lineno)
        with cg.try_squash_raise():
            cg.load_helper_from_fast('run_operator')
            cg.load_fast(self.node_stack[-1])
            cg.load_const(self.bind_stack[-1])
            cg.load_const(node.operator)
            cg.load_const(code)
            cg.load_globals_from_fast()             # helper -> node -> name -> op -> code -> globals
            cg.call_function(5)
            cg.pop_top()

    def visit_PythonExpression(self, node):
        """ The compiler visitor for a PythonExpression node.

        """
        cg = self.code_generator
        code = compile(node.ast, cg.filename, mode='eval')
        self.code_stack.append(code)

    def visit_PythonModule(self, node):
        """ The compiler visitor for a PythonModule node.

        """
        cg = self.code_generator
        code = compile(node.ast, cg.filename, mode='exec')
        self.code_stack.append(code)
