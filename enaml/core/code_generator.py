#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from contextlib import contextmanager

from atom.api import Atom, List, Str

from . import byteplay as bp


class CodeGenerator(Atom):
    """ A class for generating bytecode operations.

    """
    #: The full name of the file which is being compiled.
    filename = Str()

    #: The list of generated byteplay code operations.
    code_ops = List()

    def set_lineno(self, lineno):
        """ Set the current line number in the code.

        """
        self.code_ops.append(                           # TOS
            (bp.SetLineno, lineno),                     # TOS
        )

    def load_global(self, name):
        """ Load a global variable onto the TOS.

        """
        self.code_ops.append(                           # TOS
            (bp.LOAD_GLOBAL, name),                     # TOS -> value
        )

    def load_fast(self, name):
        """ Load a fast local variable onto the TOS.

        """
        self.code_ops.append(                           # TOS
            (bp.LOAD_FAST, name),                       # TOS -> value
        )

    def load_name(self, name):
        """ Load a named value onto the TOS.

        """
        self.code_ops.append(                           # TOS
            (bp.LOAD_NAME, name),                       # TOS -> value
        )

    def load_const(self, const):
        """ Load a const value onto the TOS.

        """
        self.code_ops.append(                           # TOS
            (bp.LOAD_CONST, const),                     # TOS -> value
        )

    def store_global(self, name):
        """ Store the TOS as a global.

        """
        self.code_ops.append(                           # TOS -> value
            (bp.STORE_GLOBAL, name),                    # TOS
        )

    def store_fast(self, name):
        """ Store the TOS as a fast local.

        """
        self.code_ops.append(                           # TOS -> value
            (bp.STORE_FAST, name),                      # TOS
        )

    def delete_global(self, name):
        """ Delete a named global variable.

        """
        self.code_ops.append(                           # TOS
            (bp.DELETE_GLOBAL, name),                   # TOS
        )

    def delete_fast(self, name):
        """ Delete a named fast local variable.

        """
        self.code_ops.append(                           # TOS
            (bp.DELETE_FAST, name),                     # TOS
        )

    def return_value(self):
        """ Return the value from the TOS.

        """
        self.code_ops.append(                           # TOS -> value
            (bp.RETURN_VALUE, None),                    # TOS
        )

    def dup_top(self):
        """ Duplicate the value on the TOS.

        """
        self.code_ops.append(                           # TOS -> value
            (bp.DUP_TOP, None),                         # TOS -> value -> value
        )

    def build_map(self, n=0):
        """ Build a map and store it onto the TOS.

        """
        self.code_ops.append(                           # TOS
            (bp.BUILD_MAP, n),                          # TOS -> map
        )

    def build_tuple(self, n=0):
        """ Build a tuple from items on the TOS.

        """
        if n == 0:
            self.code_ops.append(                       # TOS
                (bp.LOAD_CONST, ()),                    # TOS -> tuple
            )
        else:
            self.code_ops.append(                       # TOS
                (bp.BUILD_TUPLE, n),                    # TOS -> tuple
            )

    def make_function(self, n_defaults=0):
        """ Make a function from a code object on the TOS.

        """
        self.code_ops.append(                           # TOS -> code -> defaults
            (bp.MAKE_FUNCTION, n_defaults),             # TOS -> func
        )

    def call_function(self, n_args=0, n_kwds=0):
        """ Call a function on the TOS with the given args and kwargs.

        """
        argspec = ((n_kwds & 0xFF) << 8) + (n_args & 0xFF)
        self.code_ops.append(                           # TOS -> func -> args -> kwargs
            (bp.CALL_FUNCTION, argspec),                # TOS -> retval
        )

    def pop_top(self):
        """ Pop the value from the TOS.

        """
        self.code_ops.append(                           # TOS -> value
            (bp.POP_TOP, None),                         # TOS
        )

    def rot_two(self):
        """ Rotate the two values on the TOS.

        """
        self.code_ops.append(                           # TOS -> val_1 -> val_2
            (bp.ROT_TWO, None),                         # TOS -> val_2 -> val_1
        )

    def rot_three(self):
        """ Rotate the three values on the TOS.

        """
        self.code_ops.append(                           # TOS -> val_1 -> val_2 -> val_3
            (bp.ROT_THREE, None),                       # TOS -> val_3 -> val_1 -> val_2
        )

    def reverse_three(self):
        """ Reverse the three values on the TOS.

        """
        self.rot_three()
        self.rot_two()

    def load_globals(self):
        """ Load the globals onto the TOS.

        """
        self.code_ops.extend([                          # TOS
            (bp.LOAD_GLOBAL, 'globals'),                # TOS -> func
            (bp.CALL_FUNCTION, 0x0000),                 # TOS -> globals
        ])

    def store_globals_to_fast(self):
        """ Store the globals to the fast locals.

        """
        self.code_ops.extend([                          # TOS
            (bp.LOAD_GLOBAL, 'globals'),                # TOS -> func
            (bp.CALL_FUNCTION, 0x0000),                 # TOS -> globals
            (bp.STORE_FAST, '_[f_globals]'),            # TOS
        ])

    def load_globals_from_fast(self):
        """ Load the stored globals from the fast locals.

        """
        self.code_ops.append(                           # TOS
            (bp.LOAD_FAST, '_[f_globals]'),             # TOS -> globals
        )

    def load_helper(self, name):
        """ Load a named compiler helper onto the TOS.

        """
        self.code_ops.extend([                          # TOS
            (bp.LOAD_GLOBAL, '__compiler_helpers'),     # TOS -> helpers
            (bp.LOAD_CONST, name),                      # TOS -> helpers -> name
            (bp.BINARY_SUBSCR, None),                   # TOS -> helper
        ])

    def store_helpers_to_fast(self):
        """ Store the compiler helpers to the fast locals.

        """
        self.code_ops.extend([                          # TOS
            (bp.LOAD_GLOBAL, '__compiler_helpers'),     # TOS -> helpers
            (bp.STORE_FAST, '_[helpers]'),              # TOS
        ])

    def load_helper_from_fast(self, name):
        """ Load the stored helper from the fast locals.

        """
        self.code_ops.extend([                          # TOS
            (bp.LOAD_FAST, '_[helpers]'),               # TOS -> helpers
            (bp.LOAD_CONST, name),                      # TOS -> helpers -> name
            (bp.BINARY_SUBSCR, None),                   # TOS -> helper
        ])

    @contextmanager
    def try_squash_raise(self):
        """ A context manager for squashing tracebacks.

        The code written during this context will be wrapped so that
        any exception raised will appear to have been generated from
        the code, rather than any function called by the code.

        """
        exc_label = bp.Label()
        end_label = bp.Label()
        self.code_ops.append(
            (bp.SETUP_EXCEPT, exc_label),               # TOS
        )
        yield
        self.code_ops.extend([                          # TOS
            (bp.POP_BLOCK, None),                       # TOS
            (bp.JUMP_FORWARD, end_label),               # TOS
            (exc_label, None),                          # TOS -> tb -> val -> exc
            (bp.ROT_THREE, None),                       # TOS -> exc -> tb -> val
            (bp.ROT_TWO, None),                         # TOS -> exc -> val -> tb
            (bp.POP_TOP, None),                         # TOS -> exc -> val
            (bp.RAISE_VARARGS, 2),                      # TOS
            (bp.JUMP_FORWARD, end_label),               # TOS
            (bp.END_FINALLY, None),                     # TOS
            (end_label, None),                          # TOS
        ])

    def insert_python_block(self, pydata):
        """ Insert the compiled code for a Python Module ast or string.

        """
        code = compile(pydata, self.filename, mode='exec')
        bp_code = bp.Code.from_code(code).code
        self.code_ops.extend(bp_code[1:-2])  # skip SetLineno and ReturnValue

    def insert_python_expr(self, pydata):
        """ Insert the compiled code for a Python Expression ast or string.

        """
        code = compile(pydata, self.filename, mode='eval')
        bp_code = bp.Code.from_code(code).code
        self.code_ops.extend(bp_code[:-1])  # skip ReturnValue

    def to_code(self, freevars=[], args=[], varargs=False, varkwargs=False,
                newlocals=False, name='', firstlineno=0, docstring=None):
        """ Create a Python code object from the current code ops.

        """
        bp_code = bp.Code(
            self.code_ops, freevars[:], args[:], varargs, varkwargs,
            newlocals, name, self.filename, firstlineno, docstring,
        )
        return bp_code.to_code()
