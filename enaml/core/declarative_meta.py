#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Atom, AtomMeta, DefaultValue, Member, Typed


class DeclarativeDefaultHandler(Atom):
    """ A callable object which handles Declarative default values.

    This handler attempts to read the default value from the declarative
    engine, falling back on the default delegate if the engine does not
    have an implemented reader. Instances of this handler are created
    and installed by the DeclarativeMeta class.

    """
    delegate = Typed(Member, ())

    def __call__(self, owner, name):
        """ Invoke the declarative default handler.

        Parameters
        ----------
        owner : Declarative
            The declarative owner for which the default value should
            be computed.

        name : str
            The name of the attribute which should be read from the
            declarative engine.

        Returns
        -------
        result : object
            The default value for the object.

        """
        engine = owner._d_engine
        if engine is not None:
            value = engine.read(owner, name)
            if value is not NotImplemented:
                return value
        return self.delegate.do_default_value(owner)


def declarative_change_handler(change):
    """ A static observer which writes to a declarative engine.

    This handler will write the change to the declarative engine
    so that the engine can notify any bound expressions. This handler
    is attached by the DeclarativeMeta class.

    Parameters
    ----------
    change : dict
        The change dictionary generated by the notification.

    """
    change_t = change['type']
    if change_t == 'update' or change_t == 'event':
        owner = change['object']
        engine = owner._d_engine
        if engine is not None:
            engine.write(owner, change['name'], change)


class DeclarativeMeta(AtomMeta):
    """ The metaclass for Declarative classes.

    This metaclass patches up the default value handlers and default
    static observers based on the 'd_' members defined on the class.
    The patching must be done after the parent metaclass runs, since
    the bindings for the default engine must occur after the standard
    default handler hookups.

    """
    def __new__(meta, name, bases, dct):
        """ Create a new Declarative subclass.

        """
        # Create the subclass then pass over it's update dict and
        # patch up the default value and static change handlers for
        # the d_ members. This must done *after* the main metaclass
        # runs, or the declarative default values can get clobbered.
        cls = AtomMeta.__new__(meta, name, bases, dct)
        for key, value in cls.__dict__.iteritems():
            if isinstance(value, Member):
                metadata = value.metadata
                if metadata is not None and metadata.get('d_member'):
                    if metadata['d_writable']:
                        mode, ctxt = value.default_value_mode
                        handler = DeclarativeDefaultHandler()
                        handler.delegate = value.clone()
                        new_mode = DefaultValue.CallObject_ObjectName
                        value.set_default_value_mode(new_mode, handler)
                    if metadata['d_readable']:
                        value.add_static_observer(declarative_change_handler)
        return cls
