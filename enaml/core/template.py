#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from types import FunctionType

from atom.api import Atom, Bool, List, Str, Tuple, Typed

from .byteplay import CO_VARARGS
from .compiler_nodes import TemplateNode


class TemplateInstance(Atom):
    """ A class representing a template instantiation.

    """
    #: The template node generated by the specialization.
    node = Typed(TemplateNode)

    def __call__(self, parent=None, **kwargs):
        """ Instantiate the list of items for the template.

        Parameters
        ----------
        parent : Object or None
            The parent object for the generated objects.

        **kwargs
            Additional keyword arguments to pass to the generated
            objects during construction.

        """
        # XXX fixme!
        res = []
        for child in self.node.children:
            res.append(child.klass(parent, **kwargs))
        return res


class Specialization(Atom):
    """ A class which represents the specialization of a template.

    Instances of this class are created by a Template instance.

    """
    #: The function which builds the TemplateNode.
    func = Typed(FunctionType)

    #: Whether or not the function is variadic.
    variadic = Bool()

    #: The parameter type specification.
    paramspec = Tuple()


class Template(Atom):
    """ A class representing a 'template' definition.

    """
    #: The name associated with the template.
    name = Str()

    #: The module name in which the template lives.
    module = Str()

    #: The list of specializations associated with the template. This
    #: list is populated by the compiler.
    specializations = List(Specialization)

    #: The cache of template instantiations.
    cache = Typed(dict, ())

    def __repr__(self):
        """ A nice repr for objects created by the `template` keyword.

        """
        return "<template '%s.%s'>" % (self.module, self.name)

    def add_specialization(self, paramspec, func):
        """ Add a specialization to the template.

        Parameters
        ----------
        paramspec : tuple
            A tuple specifying the specializations for the function.

        func : FunctionType
            A function which will return a TemplateNode when invoked
            with user arguments.

        """
        for spec in self.specializations:
            if spec.paramspec == paramspec:
                msg = 'ambiguous specialization for parameters: %s'
                raise TypeError(msg % (paramspec,))
        spec = Specialization()
        spec.func = func
        spec.paramspec = paramspec
        spec.variadic = bool(func.func_code.co_flags & CO_VARARGS)
        self.specializations.append(spec)

    def match_specialization(self, args):
        """ Match the args against the specializations.

        Parameters
        ----------
        args : tuple
            A tuple of arguments for the instantiation.

        Returns
        -------
        result : Specialization or None
            The best matching specialization for the args, or None if
            no match could be found.

        """
        matches = []
        n_args = len(args)
        for spec in self.specializations:
            n_params = len(spec.paramspec)
            if n_args < n_params:
                continue
            if n_args > n_params and not spec.variadic:
                continue
            score = 0
            for arg, param in zip(args, spec.paramspec):
                if arg == param:
                    continue
                if param is None:
                    score += 1
                    continue
                score = -1
                break
            if score >= 0:
                key = (score, n_args - n_params)
                matches.append((key, spec))
        if matches:
            if len(matches) == 1:
                return matches[0][1]
            matches.sort()
            score_0, match_0 = matches[0]
            score_1, match_1 = matches[1]
            if score_0 == score_1:
                msg = "ambiguous instantiation for arguments: %s"
                raise TypeError(msg % (args,))
            return match_0

    def __call__(self, *args):
        """ Instantiate the template for the given arguments.

        Parameters
        ----------
        *args
            The arguments to use to instantiate the template.

        Returns
        -------
        result : TemplateInstance
            The instantiated template.

        """
        inst = self.cache.get(args)
        if inst is not None:
            return inst
        spec = self.match_specialization(args)
        if spec is not None:
            inst = TemplateInstance()
            inst.node = spec.func(*args)
            self.cache[args] = inst
            return inst
        msg = 'no matching specialization for arguments: %s'
        raise TypeError(msg % (args,))
